<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Programação Funcional | Blog do Bizarro</title><meta name=keywords content><meta name=description content="Fala pessoal, beleza?
Hoje vamos ver sobre o paradigma de programação funcional, um pouco de sua história e vamos resolver o FizzBuzz usando a linguagem Clojure.
O Paradigma O paradigma funcional tem como base o uso de funções para a realização das operações. Quando falamos em função, é literalmente uma função matemática (aquelas funções que você deve ter visto na escola)
Considere a função:
f(x) = x * 2 avaliar este texto"><meta name=author content><link rel=canonical href=https://fabianobizarro.dev/blog/posts/programacao-funcional/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/blog/assets/js/highlight.min.b95bacdc39e37a332a9f883b1e78be4abc1fdca2bc1f2641f55e3cd3dabd4d61.js integrity="sha256-uVus3DnjejMqn4g7Hni+Srwf3KK8HyZB9V4809q9TWE=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://fabianobizarro.dev/blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://fabianobizarro.dev/blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://fabianobizarro.dev/blog/favicon-32x32.png><link rel=apple-touch-icon href=https://fabianobizarro.dev/blog/apple-touch-icon.png><link rel=mask-icon href=https://fabianobizarro.dev/blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.102.1"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Programação Funcional"><meta property="og:description" content="Fala pessoal, beleza?
Hoje vamos ver sobre o paradigma de programação funcional, um pouco de sua história e vamos resolver o FizzBuzz usando a linguagem Clojure.
O Paradigma O paradigma funcional tem como base o uso de funções para a realização das operações. Quando falamos em função, é literalmente uma função matemática (aquelas funções que você deve ter visto na escola)
Considere a função:
f(x) = x * 2 avaliar este texto"><meta property="og:type" content="article"><meta property="og:url" content="https://fabianobizarro.dev/blog/posts/programacao-funcional/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-08-19T22:59:44-03:00"><meta property="article:modified_time" content="2022-08-19T22:59:44-03:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Programação Funcional"><meta name=twitter:description content="Fala pessoal, beleza?
Hoje vamos ver sobre o paradigma de programação funcional, um pouco de sua história e vamos resolver o FizzBuzz usando a linguagem Clojure.
O Paradigma O paradigma funcional tem como base o uso de funções para a realização das operações. Quando falamos em função, é literalmente uma função matemática (aquelas funções que você deve ter visto na escola)
Considere a função:
f(x) = x * 2 avaliar este texto"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://fabianobizarro.dev/blog/posts/"},{"@type":"ListItem","position":2,"name":"Programação Funcional","item":"https://fabianobizarro.dev/blog/posts/programacao-funcional/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Programação Funcional","name":"Programação Funcional","description":"Fala pessoal, beleza?\nHoje vamos ver sobre o paradigma de programação funcional, um pouco de sua história e vamos resolver o FizzBuzz usando a linguagem Clojure.\nO Paradigma O paradigma funcional tem como base o uso de funções para a realização das operações. Quando falamos em função, é literalmente uma função matemática (aquelas funções que você deve ter visto na escola)\nConsidere a função:\nf(x) = x * 2 avaliar este texto","keywords":[],"articleBody":"Fala pessoal, beleza?\nHoje vamos ver sobre o paradigma de programação funcional, um pouco de sua história e vamos resolver o FizzBuzz usando a linguagem Clojure.\nO Paradigma O paradigma funcional tem como base o uso de funções para a realização das operações. Quando falamos em função, é literalmente uma função matemática (aquelas funções que você deve ter visto na escola)\nConsidere a função:\nf(x) = x * 2 avaliar este texto\nEssa função recebe um parâmetro (X) e retorna o dobro do valor (x * 2). Esta função não faz nada além de calcular o dobro do valor (para qualquer valor informado, sempre será calculado o dobro) e nunca altera o valor de X - ele sempre vai ser X independente de qualquer coisa. Este conceito de função é aplicado para qualquer tipo de processamento neste paradigma.\nUma função pode ser categorizada entre pura e impura.\nAs funções puras são aquelas que sempre retornam o mesmo valor, de acordo com os parâmetros passados, e não possuem efeitos colaterais (um efeito colateral seria uma alteração de uma variável, chamado a um banco de dados, interação com o teclado ou qualquer coisa do tipo); daí o nome “pura”. As funções impuras são o contrário, elas podem ter efeitos colaterais e resultado da função pode variar a cada execução de um determinado parâmetro de entrada. Imutabilidade\nUma característica importante neste paradigma é a imutabilidade: uma vez que um dado é criado, ele não é modificado por estas funções, mas é gerado um novo valor com base na informação original. Isto te dá a garantia de que você não vai perder o valor original de sua variável.\nComo no exemplo anterior f(x) = x * 2, a variável x terá sempre o mesmo valor; esta função não modifica o valor de x, mas cria um novo valor, que é o resultado de x * 2.\nVocê pode achar que a imutabilidade não faz sentido ou não seja necessária para seu código, mas em muitos casos, ter a garantia de que sua informação não será modificada é extremamente importante.\nComposição\nOutra característica bastante utilizada é a composição. Isso permite com que você possa agrupar funções que irão processar algo em sequência - o resultado de uma função é passado para outra, e assim é feito em sequência. Pense em um fluxo onde você pode adicionar ou remover algum processamento de forma muito fácil, além do fato de que você pode testar essas funções separadamente de forma prática.\n// declarando as funções de forma separada add1 = x =\u003e x + 1; sub1 = x =\u003e x - 1; div2 = x =\u003e x / 2 mult3 = x =\u003e x * 3 // poderíamos chamar essas funções de forma encadeada assim result = mult3(div2(sub1(add1(6)))) result // 9 /* * ou em muitos casos em linguagens funcionais, * poderíamos mesclar e compor estas funções * de uma forma parecida com esta */ result = 6 \u003e add1 \u003e sub1 \u003e div2 \u003e mult3 result // 9 Um pouco de história A programação funcional é baseada em um sistema criado por um matemático chamado Alonzo Church.\nEm 1936, Church publicou um artigo introduzindo o Cálculo Lambda (ou Cálculo-λ). Este é um sistema formal para expressar modelos computacionais através de funções; em tese é possível expressar qualquer operação utilizando este sistema.\nUma função que recebe um parâmetro e retorna o seu valor mais 1 pode ser representada da seguinte forma:\nλx.x+1 As linguagens de programação funcional tem como base o sistema do cálculo lambda, daí temos os conceitos e representações parecidos.\nChurch foi orientador de doutorado de Alan Turing. Os dois têm trabalhos semelhantes, onde as mesmas tarefas computacionais que podem ser representadas no Cálculo Lambda podem ser representadas em uma Máquina de Turing.\nLisp e Clojure Lisp é uma linguagem criada baseada no Cálculo Lambda. Lisp foi criada em 1958 por John McCarthy; seu nome vem do termo “LISt Processor”\nHoje quando falamos em Lisp nos referimos à uma família de linguagens, família que possui vários “dialetos” como Racket, Common Lisp, Scheme e Clojure, que vamos utilizar hoje.\nLogo, se você conhecer alguma linguagem que “é da família Lisp”, essa linguagem provavelmente terá uma sintaxe muito parecida com todas as da família.\nÉ uma linguagem dinâmica e multi paradigma que possui uma sintaxe, digamos, peculiar (ao menos para quem nunca teve contato), fazendo uso de recursos e padrões diferentes dos que estamos acostumados nas linguagens de programação mais comuns hoje em dia.\nUm exemplo é o uso da notação prefixa (ou notação polonesa) onde o operador vem antes dos operandos. Uma operação como 2 + 2 seria representada dessa forma: + 2 2, isso vale para as outras operações, como a de comparação \u003e 2 1.\nOutra característica é o uso de parênteses na representação das expressões (S-expressions) e nas chamadas de funções. Para chamar uma função callFunc em uma linguagem baseada em C por exemplo, basta chamar callFunc() desta forma; em Lisp a sintaxe ficaria assim: (callfunc), com o nome da função entre parêntesis.\nClojure Clojure é uma linguagem de programação (um dialeto de Lisp) criada em 2007 por Rich Hickey. É uma linguagem dinâmica e roda em cima da JVM (Java Virtual Machine).\nPor ser um dialeto de Lisp, apresenta as mesmas características citadas acima. Para exemplo, uma função como:\nfunction addNumbers(x, y) { return x + y; } addNumbers(2, 2); // 4 Ficaria assim em Clojure:\n(defn addNumbers [x y] (+ x y)) (addNumbers 2 2) ;; 4 Aquele exemplo que comentei sobre a composição, onde podemos utilizar funções de forma encadeada? Em Clojure, podemos ter algo assim:\n(defn add1 [n] (+ n 1)) (defn sub1 [n] (- n 1)) (defn div2 [n] (/ n 2)) (defn mult3 [n] (* n 3)) (-\u003e 6 add1 sub1 div2 mult3) ;; 4 Sim, no começo parece estranho, mas você se acostuma.\nResolvendo o FizzBuzz Vamos ao que interessa, resolver o FizzBuzz usando o paradigma declarativo funcional.\nPrimeiro, vamos criar uma função mapNumber que receba um número e converta para o resultado esperado: Fizz, Buzz, FizzBuzz ou o próprio número.\n;; isso é um comentário em clojure (defn mapNumber ;; nome do método [i] ;; declaração do parâmetro ;; corpo da função aqui ) A seguir, nós usamos uma função chamada cond para testar todas as possibilidades de divisão. Aqui nós também temos o operador mod para ajudar a verificar se um número é divisível por outro.\nPara verificar se um número é igual a 0, por exemplo, nós usamos a operação (= i 0); para encontrar o resto da divisão de um número por 3, usamos a operação (mod i 3).\nEm uma linguagem com a notação infixa (a que você provavelmente está acostumado), essa expressão ficaria parecida com isso:\ni mod 3 == 0 Em Clojure, nós temos\n(= 0 (mod i 3)) Tendo essa expressão em mente, vamos usá-las para montar nossa expressão de validação usando cond. Basta adicionar essas condições em uma sequência, junto com o valor desejado de retorno caso aquela expressão seja satisfeita. Se nada for encontrado, então retornamos o próprio número.\n(cond (= 0 (mod i 15)) \"FizzBuzz\" (= 0 (mod i 5)) \"Buzz\" (= 0 (mod i 3)) \"Fizz\" :else (str i)) Agora, basta adicionar essa expressão em nossa função mapNumber e temos nosso mapeamento completo. Para validar a função, basta chamá-la passando algum número e verificar o retorno.\n(defn mapNumber [i] (cond (= 0 (mod i 15)) \"FizzBuzz\" (= 0 (mod i 5)) \"Buzz\" (= 0 (mod i 3)) \"Fizz\" :else (str i))) (mapNumber 1) ;; 1 (mapNumber 3) ;; Fizz (mapNumber 5) ;; Buzz (mapNumber 15) ;; FizzBuzz Agora precisamos gerar uma lista de 1 até n numeros e gerar nosso fizzbuzz.\nNós vamos usar a função range para gerar uma coleção de número de 1 até n e então usar nossa função mapNumber para mapear esses resultados. Essa lógica ficará em uma função chamada fizzbuzz.\n(defn fizzbuzz [n] (range 1 n)) (fizzbuzz 10) ;; (1 2 3 4 5 6 7 8 9) Se chamarmos essa função, ela retornará uma coleção com os números gerados.\nVamos aplicar uma função map sobre esses números para podermos transformar esses valores.\n(map funcao-de-mapeamento (range 1 n)) Qualquer função que passarmos nesse map será chamada para todos os itens da coleção. Vamos usar nossa função mapNumber.\n(map mapNumber (range 1 n)) Nossa função fizzbuzz ficaria assim\n(defn fizzbuzz [n] (map mapNumber (range 1 n))) Pronto, se chamar a função passando algum número, teremos nosso fizzbuzz.\n(fizzbuzz 16) ;; (\"1\" \"2\" \"Fizz\" \"4\" \"Buzz\" \"Fizz\" \"7\" \"8\" \"Fizz\" \"Buzz\" \"11\" \"Fizz\" \"13\" \"14\" \"FizzBuzz\") Uma melhoria que podemos fazer é criar um comportamento diferente no método, de acordo com o número de argumentos passados. Se recebermos o argumento n, vamos chamar a função map normalmente; se não recebermos um argumento n, então vamos chamar a função fizzbuzz recursivamente, passando o argumento n com um valor padrão.\n(defn fizzbuzz ([n] (map mapNumber (range 1 n))) ([] (fizzbuzz 10))) O código final fica assim:\n(defn mapNumber [i] (cond (= 0 (mod i 15)) \"FizzBuzz\" (= 0 (mod i 5)) \"Buzz\" (= 0 (mod i 3)) \"Fizz\" :else (str i))) (defn fizzbuzz ([n] (map mapNumber (range 1 n))) ([] (fizzbuzz 10))) Repare como ficou o código e como ele fica diferente de uma linguagem imperativa. A sensação que eu tenho é que estou escrevendo uma receita de como eu quero o resultado do meu código, e não como o computador deve excecutar as instruções.\nConclusão Vimos como o paradigma funcional se difere do imperativo, tanto no estilo de programação, quanto em suas características. Diferente de um paradigma imperativo, aqui nós não temos instruções de execução como for ou if/else, mas declarações de funcões e mapeamento de dados. O resultado é o meso, mas conseguims atingi-lo de formas diferentes.\nTambém conhecemos uma linguagem diferente do que provavelmente estamos acostumados, com características peculiares. Acredito que vale a pena dar uma atenção para uma lingaguem da família Lisp.\nPor fim, implementamos o FizzBuzz usando uma lingaugem declarativa funcional.\nAté a próxima!\n","wordCount":"1675","inLanguage":"en","datePublished":"2022-08-19T22:59:44-03:00","dateModified":"2022-08-19T22:59:44-03:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://fabianobizarro.dev/blog/posts/programacao-funcional/"},"publisher":{"@type":"Organization","name":"Blog do Bizarro","logo":{"@type":"ImageObject","url":"https://fabianobizarro.dev/blog/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://fabianobizarro.dev/blog/ accesskey=h title="Blog do Bizarro (Alt + H)">Blog do Bizarro</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://fabianobizarro.dev/blog/archives title=Arquivo><span>Arquivo</span></a></li><li><a href=https://fabianobizarro.dev/blog/search/ title=Pesquisar><span>Pesquisar</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://fabianobizarro.dev/blog/>Home</a>&nbsp;»&nbsp;<a href=https://fabianobizarro.dev/blog/posts/>Posts</a></div><h1 class=post-title>Programação Funcional</h1><div class=post-meta><span title='2022-08-19 22:59:44 -0300 -0300'>August 19, 2022</span>&nbsp;·&nbsp;8 min</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#o-paradigma aria-label="O Paradigma">O Paradigma</a></li><li><a href=#um-pouco-de-hist%c3%b3ria aria-label="Um pouco de história">Um pouco de história</a></li><li><a href=#lisp-e-clojure aria-label="Lisp e Clojure">Lisp e Clojure</a><ul><li><a href=#clojure aria-label=Clojure>Clojure</a></li></ul></li><li><a href=#resolvendo-o-fizzbuzz aria-label="Resolvendo o FizzBuzz">Resolvendo o FizzBuzz</a></li><li><a href=#conclus%c3%a3o aria-label=Conclusão>Conclusão</a></li></ul></div></details></div><div class=post-content><p>Fala pessoal, beleza?</p><p>Hoje vamos ver sobre o paradigma de programação funcional, um pouco de sua história e vamos resolver o FizzBuzz usando a linguagem Clojure.</p><h2 id=o-paradigma>O Paradigma<a hidden class=anchor aria-hidden=true href=#o-paradigma>#</a></h2><p>O paradigma funcional tem como base o uso de funções para a realização das operações. Quando falamos em função, é literalmente uma função matemática (aquelas funções que você deve ter visto na escola)</p><p>Considere a função:</p><pre tabindex=0><code>f(x) = x * 2
</code></pre><p>avaliar este texto</p><p>Essa função recebe um parâmetro (X) e retorna o dobro do valor (x * 2). Esta função não faz nada além de calcular o dobro do valor (para qualquer valor informado, sempre será calculado o dobro) e nunca altera o valor de X - ele sempre vai ser X independente de qualquer coisa. Este conceito de função é aplicado para qualquer tipo de processamento neste paradigma.</p><p>Uma função pode ser categorizada entre <strong>pura</strong> e <strong>impura</strong>.</p><ul><li>As funções puras são aquelas que sempre retornam o mesmo valor, de acordo com os parâmetros passados, e não possuem efeitos colaterais (um efeito colateral seria uma alteração de uma variável, chamado a um banco de dados, interação com o teclado ou qualquer coisa do tipo); daí o nome “pura”.</li><li>As funções impuras são o contrário, elas podem ter efeitos colaterais e resultado da função pode variar a cada execução de um determinado parâmetro de entrada.</li></ul><p><strong>Imutabilidade</strong></p><p>Uma característica importante neste paradigma é a imutabilidade: uma vez que um dado é criado, ele não é modificado por estas funções, mas é gerado um novo valor com base na informação original. Isto te dá a garantia de que você não vai perder o valor original de sua variável.</p><p>Como no exemplo anterior <code>f(x) = x * 2</code>, a variável <code>x</code> terá sempre o mesmo valor; esta função não modifica o valor de <code>x</code>, mas cria um novo valor, que é o resultado de <code>x * 2</code>.</p><p>Você pode achar que a imutabilidade não faz sentido ou não seja necessária para seu código, mas em muitos casos, ter a garantia de que sua informação não será modificada é extremamente importante.</p><p><strong>Composição</strong></p><p>Outra característica bastante utilizada é a composição. Isso permite com que você possa agrupar funções que irão processar algo em sequência - o resultado de uma função é passado para outra, e assim é feito em sequência. Pense em um fluxo onde você pode adicionar ou remover algum processamento de forma muito fácil, além do fato de que você pode testar essas funções separadamente de forma prática.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#75715e>// declarando as funções de forma separada
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>add1</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>x</span> =&gt; <span style=color:#a6e22e>x</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>sub1</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>x</span> =&gt; <span style=color:#a6e22e>x</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>div2</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>x</span> =&gt; <span style=color:#a6e22e>x</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>mult3</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>x</span> =&gt; <span style=color:#a6e22e>x</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// poderíamos chamar essas funções de forma encadeada assim
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>result</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>mult3</span>(<span style=color:#a6e22e>div2</span>(<span style=color:#a6e22e>sub1</span>(<span style=color:#a6e22e>add1</span>(<span style=color:#ae81ff>6</span>))))
</span></span><span style=display:flex><span><span style=color:#a6e22e>result</span> <span style=color:#75715e>// 9
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e> * ou em muitos casos em linguagens funcionais, 
</span></span></span><span style=display:flex><span><span style=color:#75715e> * poderíamos mesclar e compor estas funções 
</span></span></span><span style=display:flex><span><span style=color:#75715e> * de uma forma parecida com esta
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>result</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>6</span> <span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>add1</span> <span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>sub1</span> <span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>div2</span> <span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>mult3</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>result</span> <span style=color:#75715e>// 9
</span></span></span></code></pre></div><h2 id=um-pouco-de-história>Um pouco de história<a hidden class=anchor aria-hidden=true href=#um-pouco-de-história>#</a></h2><p>A programação funcional é baseada em um sistema criado por um matemático chamado Alonzo Church.</p><p>Em 1936, Church publicou um artigo introduzindo o Cálculo Lambda (ou Cálculo-λ). Este é um sistema formal para expressar modelos computacionais através de funções; em tese é possível expressar qualquer operação utilizando este sistema.</p><p>Uma função que recebe um parâmetro e retorna o seu valor mais 1 pode ser representada da seguinte forma:</p><pre tabindex=0><code class=language-math data-lang=math>λx.x+1
</code></pre><p>As linguagens de programação funcional tem como base o sistema do cálculo lambda, daí temos os conceitos e representações parecidos.</p><p>Church foi orientador de doutorado de Alan Turing. Os dois têm trabalhos semelhantes, onde as mesmas tarefas computacionais que podem ser representadas no Cálculo Lambda podem ser representadas em uma Máquina de Turing.</p><h2 id=lisp-e-clojure>Lisp e Clojure<a hidden class=anchor aria-hidden=true href=#lisp-e-clojure>#</a></h2><p>Lisp é uma linguagem criada baseada no Cálculo Lambda. Lisp foi criada em 1958 por John McCarthy; seu nome vem do termo “<strong>LIS</strong>t <strong>P</strong>rocessor”</p><p>Hoje quando falamos em Lisp nos referimos à uma família de linguagens, família que possui vários “dialetos” como Racket, Common Lisp, Scheme e Clojure, que vamos utilizar hoje.</p><p>Logo, se você conhecer alguma linguagem que “é da família Lisp”, essa linguagem provavelmente terá uma sintaxe muito parecida com todas as da família.</p><p>É uma linguagem dinâmica e multi paradigma que possui uma sintaxe, digamos, peculiar (ao menos para quem nunca teve contato), fazendo uso de recursos e padrões diferentes dos que estamos acostumados nas linguagens de programação mais comuns hoje em dia.</p><p>Um exemplo é o uso da notação prefixa (ou notação polonesa) onde o operador vem antes dos operandos. Uma operação como <code>2 + 2</code> seria representada dessa forma: <code>+ 2 2</code>, isso vale para as outras operações, como a de comparação <code>> 2 1</code>.</p><p>Outra característica é o uso de parênteses na representação das expressões (S-expressions) e nas chamadas de funções. Para chamar uma função <code>callFunc</code> em uma linguagem baseada em C por exemplo, basta chamar <code>callFunc()</code> desta forma; em Lisp a sintaxe ficaria assim: <code>(callfunc)</code>, com o nome da função entre parêntesis.</p><h3 id=clojure>Clojure<a hidden class=anchor aria-hidden=true href=#clojure>#</a></h3><p>Clojure é uma linguagem de programação (um dialeto de Lisp) criada em 2007 por Rich Hickey. É uma linguagem dinâmica e roda em cima da JVM (Java Virtual Machine).</p><p>Por ser um dialeto de Lisp, apresenta as mesmas características citadas acima. Para exemplo, uma função como:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>addNumbers</span>(<span style=color:#a6e22e>x</span>, <span style=color:#a6e22e>y</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>x</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>y</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>addNumbers</span>(<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>2</span>); <span style=color:#75715e>// 4
</span></span></span></code></pre></div><p>Ficaria assim em Clojure:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clj data-lang=clj><span style=display:flex><span>(<span style=color:#66d9ef>defn </span>addNumbers [x y]
</span></span><span style=display:flex><span>	(+ x y))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(<span style=color:#a6e22e>addNumbers</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>2</span>) <span style=color:#75715e>;; 4</span>
</span></span></code></pre></div><p>Aquele exemplo que comentei sobre a composição, onde podemos utilizar funções de forma encadeada? Em Clojure, podemos ter algo assim:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clj data-lang=clj><span style=display:flex><span>(<span style=color:#66d9ef>defn </span>add1 [n] (+ n <span style=color:#ae81ff>1</span>))
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>defn </span>sub1 [n] (- n <span style=color:#ae81ff>1</span>))
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>defn </span>div2 [n] (/ n <span style=color:#ae81ff>2</span>))
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>defn </span>mult3 [n] (* n <span style=color:#ae81ff>3</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(-&gt; <span style=color:#ae81ff>6</span> add1 sub1 div2 mult3) <span style=color:#75715e>;; 4</span>
</span></span></code></pre></div><p>Sim, no começo parece estranho, mas você se acostuma.</p><h2 id=resolvendo-o-fizzbuzz>Resolvendo o FizzBuzz<a hidden class=anchor aria-hidden=true href=#resolvendo-o-fizzbuzz>#</a></h2><p>Vamos ao que interessa, resolver o FizzBuzz usando o paradigma declarativo funcional.</p><p>Primeiro, vamos criar uma função <code>mapNumber</code> que receba um número e converta para o resultado esperado: Fizz, Buzz, FizzBuzz ou o próprio número.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clj data-lang=clj><span style=display:flex><span><span style=color:#75715e>;; isso é um comentário em clojure</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>defn </span>mapNumber <span style=color:#75715e>;; nome do método</span>
</span></span><span style=display:flex><span>  [i] <span style=color:#75715e>;; declaração do parâmetro</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>;; corpo da função aqui</span>
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><p>A seguir, nós usamos uma função chamada <code>cond</code> para testar todas as possibilidades de divisão. Aqui nós também temos o operador <code>mod</code> para ajudar a verificar se um número é divisível por outro.</p><p>Para verificar se um número é igual a 0, por exemplo, nós usamos a operação <code>(= i 0)</code>; para encontrar o resto da divisão de um número por 3, usamos a operação <code>(mod i 3)</code>.</p><p>Em uma linguagem com a notação infixa (a que você provavelmente está acostumado), essa expressão ficaria parecida com isso:</p><pre tabindex=0><code>i mod 3 == 0
</code></pre><p>Em Clojure, nós temos</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clj data-lang=clj><span style=display:flex><span>(= <span style=color:#ae81ff>0</span> (<span style=color:#a6e22e>mod</span> i <span style=color:#ae81ff>3</span>))
</span></span></code></pre></div><p>Tendo essa expressão em mente, vamos usá-las para montar nossa expressão de validação usando <code>cond</code>. Basta adicionar essas condições em uma sequência, junto com o valor desejado de retorno caso aquela expressão seja satisfeita. Se nada for encontrado, então retornamos o próprio número.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clj data-lang=clj><span style=display:flex><span>(<span style=color:#a6e22e>cond</span>
</span></span><span style=display:flex><span>    (= <span style=color:#ae81ff>0</span> (<span style=color:#a6e22e>mod</span> i <span style=color:#ae81ff>15</span>)) <span style=color:#e6db74>&#34;FizzBuzz&#34;</span>
</span></span><span style=display:flex><span>    (= <span style=color:#ae81ff>0</span> (<span style=color:#a6e22e>mod</span> i <span style=color:#ae81ff>5</span>)) <span style=color:#e6db74>&#34;Buzz&#34;</span>
</span></span><span style=display:flex><span>    (= <span style=color:#ae81ff>0</span> (<span style=color:#a6e22e>mod</span> i <span style=color:#ae81ff>3</span>)) <span style=color:#e6db74>&#34;Fizz&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>:else</span> (str i))
</span></span></code></pre></div><p>Agora, basta adicionar essa expressão em nossa função mapNumber e temos nosso mapeamento completo. Para validar a função, basta chamá-la passando algum número e verificar o retorno.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clj data-lang=clj><span style=display:flex><span>(<span style=color:#66d9ef>defn </span>mapNumber
</span></span><span style=display:flex><span>  [i]
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>cond</span>
</span></span><span style=display:flex><span>    (= <span style=color:#ae81ff>0</span> (<span style=color:#a6e22e>mod</span> i <span style=color:#ae81ff>15</span>)) <span style=color:#e6db74>&#34;FizzBuzz&#34;</span>
</span></span><span style=display:flex><span>    (= <span style=color:#ae81ff>0</span> (<span style=color:#a6e22e>mod</span> i <span style=color:#ae81ff>5</span>)) <span style=color:#e6db74>&#34;Buzz&#34;</span>
</span></span><span style=display:flex><span>    (= <span style=color:#ae81ff>0</span> (<span style=color:#a6e22e>mod</span> i <span style=color:#ae81ff>3</span>)) <span style=color:#e6db74>&#34;Fizz&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>:else</span> (str i)))
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>(<span style=color:#a6e22e>mapNumber</span> <span style=color:#ae81ff>1</span>)   <span style=color:#75715e>;; 1</span>
</span></span><span style=display:flex><span>(<span style=color:#a6e22e>mapNumber</span> <span style=color:#ae81ff>3</span>)   <span style=color:#75715e>;; Fizz</span>
</span></span><span style=display:flex><span>(<span style=color:#a6e22e>mapNumber</span> <span style=color:#ae81ff>5</span>)   <span style=color:#75715e>;; Buzz</span>
</span></span><span style=display:flex><span>(<span style=color:#a6e22e>mapNumber</span> <span style=color:#ae81ff>15</span>)  <span style=color:#75715e>;; FizzBuzz</span>
</span></span></code></pre></div><p>Agora precisamos gerar uma lista de 1 até n numeros e gerar nosso fizzbuzz.</p><p>Nós vamos usar a função <code>range</code> para gerar uma coleção de número de 1 até <code>n</code> e então usar nossa função <code>mapNumber</code> para mapear esses resultados. Essa lógica ficará em uma função chamada <code>fizzbuzz</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clj data-lang=clj><span style=display:flex><span>(<span style=color:#66d9ef>defn </span>fizzbuzz [n]
</span></span><span style=display:flex><span>  (range <span style=color:#ae81ff>1</span> n))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(<span style=color:#a6e22e>fizzbuzz</span> <span style=color:#ae81ff>10</span>) <span style=color:#75715e>;; (1 2 3 4 5 6 7 8 9)</span>
</span></span></code></pre></div><p>Se chamarmos essa função, ela retornará uma coleção com os números gerados.</p><p>Vamos aplicar uma função <code>map</code> sobre esses números para podermos transformar esses valores.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clj data-lang=clj><span style=display:flex><span>(map funcao-de-mapeamento (range <span style=color:#ae81ff>1</span> n))
</span></span></code></pre></div><p>Qualquer função que passarmos nesse <code>map</code> será chamada para todos os itens da coleção. Vamos usar nossa função <code>mapNumber</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clj data-lang=clj><span style=display:flex><span>(map mapNumber (range <span style=color:#ae81ff>1</span> n))
</span></span></code></pre></div><p>Nossa função fizzbuzz ficaria assim</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clj data-lang=clj><span style=display:flex><span>(<span style=color:#66d9ef>defn </span>fizzbuzz [n]
</span></span><span style=display:flex><span>  (map mapNumber (range <span style=color:#ae81ff>1</span> n)))
</span></span></code></pre></div><p>Pronto, se chamar a função passando algum número, teremos nosso fizzbuzz.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clj data-lang=clj><span style=display:flex><span>(<span style=color:#a6e22e>fizzbuzz</span> <span style=color:#ae81ff>16</span>) 
</span></span><span style=display:flex><span><span style=color:#75715e>;; (&#34;1&#34; &#34;2&#34; &#34;Fizz&#34; &#34;4&#34; &#34;Buzz&#34; &#34;Fizz&#34; &#34;7&#34; &#34;8&#34; &#34;Fizz&#34; &#34;Buzz&#34; &#34;11&#34; &#34;Fizz&#34; &#34;13&#34; &#34;14&#34; &#34;FizzBuzz&#34;)</span>
</span></span></code></pre></div><p>Uma melhoria que podemos fazer é criar um comportamento diferente no método, de acordo com o número de argumentos passados. Se recebermos o argumento n, vamos chamar a função <code>map</code> normalmente; se não recebermos um argumento <code>n</code>, então vamos chamar a função fizzbuzz recursivamente, passando o argumento <code>n</code> com um valor padrão.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clj data-lang=clj><span style=display:flex><span>(<span style=color:#66d9ef>defn </span>fizzbuzz
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  ([n] 
</span></span><span style=display:flex><span>   (map mapNumber (range <span style=color:#ae81ff>1</span> n)))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  ([]
</span></span><span style=display:flex><span>   (<span style=color:#a6e22e>fizzbuzz</span> <span style=color:#ae81ff>10</span>))) 
</span></span></code></pre></div><p>O código final fica assim:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clj data-lang=clj><span style=display:flex><span>(<span style=color:#66d9ef>defn </span>mapNumber
</span></span><span style=display:flex><span>  [i]
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>cond</span>
</span></span><span style=display:flex><span>    (= <span style=color:#ae81ff>0</span> (<span style=color:#a6e22e>mod</span> i <span style=color:#ae81ff>15</span>)) <span style=color:#e6db74>&#34;FizzBuzz&#34;</span>
</span></span><span style=display:flex><span>    (= <span style=color:#ae81ff>0</span> (<span style=color:#a6e22e>mod</span> i <span style=color:#ae81ff>5</span>)) <span style=color:#e6db74>&#34;Buzz&#34;</span>
</span></span><span style=display:flex><span>    (= <span style=color:#ae81ff>0</span> (<span style=color:#a6e22e>mod</span> i <span style=color:#ae81ff>3</span>)) <span style=color:#e6db74>&#34;Fizz&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>:else</span> (str i)))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>defn </span>fizzbuzz
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  ([n] 
</span></span><span style=display:flex><span>   (map mapNumber (range <span style=color:#ae81ff>1</span> n)))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  ([]
</span></span><span style=display:flex><span>   (<span style=color:#a6e22e>fizzbuzz</span> <span style=color:#ae81ff>10</span>))) 
</span></span></code></pre></div><p>Repare como ficou o código e como ele fica diferente de uma linguagem imperativa. A sensação que eu tenho é que estou escrevendo uma receita de como eu quero o resultado do meu código, e não como o computador deve excecutar as instruções.</p><h2 id=conclusão>Conclusão<a hidden class=anchor aria-hidden=true href=#conclusão>#</a></h2><p>Vimos como o paradigma funcional se difere do imperativo, tanto no estilo de programação, quanto em suas características. Diferente de um paradigma imperativo, aqui nós não temos instruções de execução como <code>for</code> ou <code>if/else</code>, mas declarações de funcões e mapeamento de dados. O resultado é o meso, mas conseguims atingi-lo de formas diferentes.</p><p>Também conhecemos uma linguagem diferente do que provavelmente estamos acostumados, com características peculiares. Acredito que vale a pena dar uma atenção para uma lingaguem da família Lisp.</p><p>Por fim, implementamos o FizzBuzz usando uma lingaugem declarativa funcional.</p><p>Até a próxima!</p></div><footer class=post-footer><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Programação Funcional on twitter" href="https://twitter.com/intent/tweet/?text=Programa%c3%a7%c3%a3o%20Funcional&url=https%3a%2f%2ffabianobizarro.dev%2fblog%2fposts%2fprogramacao-funcional%2f&hashtags="><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Programação Funcional on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2ffabianobizarro.dev%2fblog%2fposts%2fprogramacao-funcional%2f&title=Programa%c3%a7%c3%a3o%20Funcional&summary=Programa%c3%a7%c3%a3o%20Funcional&source=https%3a%2f%2ffabianobizarro.dev%2fblog%2fposts%2fprogramacao-funcional%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://fabianobizarro.dev/blog/>Blog do Bizarro</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>