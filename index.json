[{"content":"Fala pessoal, beleza?\nHoje vamos ver sobre o paradigma de programação funcional, um pouco de sua história e vamos resolver o FizzBuzz usando a linguagem Clojure.\nO Paradigma O paradigma funcional tem como base o uso de funções para a realização das operações. Quando falamos em função, é literalmente uma função matemática (aquelas funções que você deve ter visto na escola)\nConsidere a função:\nf(x) = x * 2 avaliar este texto\nEssa função recebe um parâmetro (X) e retorna o dobro do valor (x * 2). Esta função não faz nada além de calcular o dobro do valor (para qualquer valor informado, sempre será calculado o dobro) e nunca altera o valor de X - ele sempre vai ser X independente de qualquer coisa. Este conceito de função é aplicado para qualquer tipo de processamento neste paradigma.\nUma função pode ser categorizada entre pura e impura.\nAs funções puras são aquelas que sempre retornam o mesmo valor, de acordo com os parâmetros passados, e não possuem efeitos colaterais (um efeito colateral seria uma alteração de uma variável, chamado a um banco de dados, interação com o teclado ou qualquer coisa do tipo); daí o nome “pura”. As funções impuras são o contrário, elas podem ter efeitos colaterais e resultado da função pode variar a cada execução de um determinado parâmetro de entrada. Imutabilidade\nUma característica importante neste paradigma é a imutabilidade: uma vez que um dado é criado, ele não é modificado por estas funções, mas é gerado um novo valor com base na informação original. Isto te dá a garantia de que você não vai perder o valor original de sua variável.\nComo no exemplo anterior f(x) = x * 2, a variável x terá sempre o mesmo valor; esta função não modifica o valor de x, mas cria um novo valor, que é o resultado de x * 2.\nVocê pode achar que a imutabilidade não faz sentido ou não seja necessária para seu código, mas em muitos casos, ter a garantia de que sua informação não será modificada é extremamente importante.\nComposição\nOutra característica bastante utilizada é a composição. Isso permite com que você possa agrupar funções que irão processar algo em sequência - o resultado de uma função é passado para outra, e assim é feito em sequência. Pense em um fluxo onde você pode adicionar ou remover algum processamento de forma muito fácil, além do fato de que você pode testar essas funções separadamente de forma prática.\n// declarando as funções de forma separada add1 = x =\u0026gt; x + 1; sub1 = x =\u0026gt; x - 1; div2 = x =\u0026gt; x / 2 mult3 = x =\u0026gt; x * 3 // poderíamos chamar essas funções de forma encadeada assim result = mult3(div2(sub1(add1(6)))) result // 9 /* * ou em muitos casos em linguagens funcionais, * poderíamos mesclar e compor estas funções * de uma forma parecida com esta */ result = 6 \u0026gt; add1 \u0026gt; sub1 \u0026gt; div2 \u0026gt; mult3 result // 9 Um pouco de história A programação funcional é baseada em um sistema criado por um matemático chamado Alonzo Church.\nEm 1936, Church publicou um artigo introduzindo o Cálculo Lambda (ou Cálculo-λ). Este é um sistema formal para expressar modelos computacionais através de funções; em tese é possível expressar qualquer operação utilizando este sistema.\nUma função que recebe um parâmetro e retorna o seu valor mais 1 pode ser representada da seguinte forma:\nλx.x+1 As linguagens de programação funcional tem como base o sistema do cálculo lambda, daí temos os conceitos e representações parecidos.\nChurch foi orientador de doutorado de Alan Turing. Os dois têm trabalhos semelhantes, onde as mesmas tarefas computacionais que podem ser representadas no Cálculo Lambda podem ser representadas em uma Máquina de Turing.\nLisp e Clojure Lisp é uma linguagem criada baseada no Cálculo Lambda. Lisp foi criada em 1958 por John McCarthy; seu nome vem do termo “LISt Processor”\nHoje quando falamos em Lisp nos referimos à uma família de linguagens, família que possui vários “dialetos” como Racket, Common Lisp, Scheme e Clojure, que vamos utilizar hoje.\nLogo, se você conhecer alguma linguagem que “é da família Lisp”, essa linguagem provavelmente terá uma sintaxe muito parecida com todas as da família.\nÉ uma linguagem dinâmica e multi paradigma que possui uma sintaxe, digamos, peculiar (ao menos para quem nunca teve contato), fazendo uso de recursos e padrões diferentes dos que estamos acostumados nas linguagens de programação mais comuns hoje em dia.\nUm exemplo é o uso da notação prefixa (ou notação polonesa) onde o operador vem antes dos operandos. Uma operação como 2 + 2 seria representada dessa forma: + 2 2, isso vale para as outras operações, como a de comparação \u0026gt; 2 1.\nOutra característica é o uso de parênteses na representação das expressões (S-expressions) e nas chamadas de funções. Para chamar uma função callFunc em uma linguagem baseada em C por exemplo, basta chamar callFunc() desta forma; em Lisp a sintaxe ficaria assim: (callfunc), com o nome da função entre parêntesis.\nClojure\nClojure é uma linguagem de programação (um dialeto de Lisp) criada em 2007 por Rich Hickey. É uma linguagem dinâmica e roda em cima da JVM (Java Virtual Machine).\nPor ser um dialeto de Lisp, apresenta as mesmas características citadas acima. Para exemplo, uma função como:\nfunction addNumbers(x, y) { return x + y; } addNumbers(2, 2); // 4 Ficaria assim em Clojure:\n(defn addNumbers [x y] (+ x y)) (addNumbers 2 2) ;; 4 Aquele exemplo que comentei sobre a composição, onde podemos utilizar funções de forma encadeada? Em Clojure, podemos ter algo assim:\n(defn add1 [n] (+ n 1)) (defn sub1 [n] (- n 1)) (defn div2 [n] (/ n 2)) (defn mult3 [n] (* n 3)) (-\u0026gt; 6 add1 sub1 div2 mult3) ;; 4 Sim, no começo parece estranho, mas você se acostuma.\nResolvendo o FizzBuzz Vamos ao que interessa, resolver o FizzBuzz usando o paradigma declarativo funcional.\nPrimeiro, vamos criar uma função mapNumber que receba um número e converta para o resultado esperado: Fizz, Buzz, FizzBuzz ou o próprio número.\n;; isso é um comentário em clojure (defn mapNumber ;; nome do método [i] ;; declaração do parâmetro ;; corpo da função aqui ) A seguir, nós usamos uma função chamada cond para testar todas as possibilidades de divisão. Aqui nós também temos o operador mod para ajudar a verificar se um número é divisível por outro.\nPara verificar se um número é igual a 0, por exemplo, nós usamos a operação (= i 0); para encontrar o resto da divisão de um número por 3, usamos a operação (mod i 3).\nEm uma linguagem com a notação infixa (a que você provavelmente está acostumado), essa expressão ficaria parecida com isso:\ni mod 3 == 0 Em Clojure, nós temos\n(= 0 (mod i 3)) Tendo essa expressão em mente, vamos usá-las para montar nossa expressão de validação usando cond. Basta adicionar essas condições em uma sequência, junto com o valor desejado de retorno caso aquela expressão seja satisfeita. Se nada for encontrado, então retornamos o próprio número.\n(cond (= 0 (mod i 15)) \u0026#34;FizzBuzz\u0026#34; (= 0 (mod i 5)) \u0026#34;Buzz\u0026#34; (= 0 (mod i 3)) \u0026#34;Fizz\u0026#34; :else (str i)) Agora, basta adicionar essa expressão em nossa função mapNumber e temos nosso mapeamento completo. Para validar a função, basta chamá-la passando algum número e verificar o retorno.\n(defn mapNumber [i] (cond (= 0 (mod i 15)) \u0026#34;FizzBuzz\u0026#34; (= 0 (mod i 5)) \u0026#34;Buzz\u0026#34; (= 0 (mod i 3)) \u0026#34;Fizz\u0026#34; :else (str i))) (mapNumber 1) ;; 1 (mapNumber 3) ;; Fizz (mapNumber 5) ;; Buzz (mapNumber 15) ;; FizzBuzz Agora precisamos gerar uma lista de 1 até n numeros e gerar nosso fizzbuzz.\nNós vamos usar a função range para gerar uma coleção de número de 1 até n e então usar nossa função mapNumber para mapear esses resultados. Essa lógica ficará em uma função chamada fizzbuzz.\n(defn fizzbuzz [n] (range 1 n)) (fizzbuzz 10) ;; (1 2 3 4 5 6 7 8 9) Se chamarmos essa função, ela retornará uma coleção com os números gerados.\nVamos aplicar uma função map sobre esses números para podermos transformar esses valores.\n(map funcao-de-mapeamento (range 1 n)) Qualquer função que passarmos nesse map será chamada para todos os itens da coleção. Vamos usar nossa função mapNumber.\n(map mapNumber (range 1 n)) Nossa função fizzbuzz ficaria assim\n(defn fizzbuzz [n] (map mapNumber (range 1 n))) Pronto, se chamar a função passando algum número, teremos nosso fizzbuzz.\n(fizzbuzz 16) ;; (\u0026#34;1\u0026#34; \u0026#34;2\u0026#34; \u0026#34;Fizz\u0026#34; \u0026#34;4\u0026#34; \u0026#34;Buzz\u0026#34; \u0026#34;Fizz\u0026#34; \u0026#34;7\u0026#34; \u0026#34;8\u0026#34; \u0026#34;Fizz\u0026#34; \u0026#34;Buzz\u0026#34; \u0026#34;11\u0026#34; \u0026#34;Fizz\u0026#34; \u0026#34;13\u0026#34; \u0026#34;14\u0026#34; \u0026#34;FizzBuzz\u0026#34;) Uma melhoria que podemos fazer é criar um comportamento diferente no método, de acordo com o número de argumentos passados. Se recebermos o argumento n, vamos chamar a função map normalmente; se não recebermos um argumento n, então vamos chamar a função fizzbuzz recursivamente, passando o argumento n com um valor padrão.\n(defn fizzbuzz ([n] (map mapNumber (range 1 n))) ([] (fizzbuzz 10))) O código final fica assim:\n(defn mapNumber [i] (cond (= 0 (mod i 15)) \u0026#34;FizzBuzz\u0026#34; (= 0 (mod i 5)) \u0026#34;Buzz\u0026#34; (= 0 (mod i 3)) \u0026#34;Fizz\u0026#34; :else (str i))) (defn fizzbuzz ([n] (map mapNumber (range 1 n))) ([] (fizzbuzz 10))) Repare como ficou o código e como ele fica diferente de uma linguagem imperativa. A sensação que eu tenho é que estou escrevendo uma receita de como eu quero o resultado do meu código, e não como o computador deve excecutar as instruções.\nConclusão Vimos como o paradigma funcional se difere do imperativo, tanto no estilo de programação, quanto em suas características. Diferente de um paradigma imperativo, aqui nós não temos instruções de execução como for ou if/else, mas declarações de funcões e mapeamento de dados. O resultado é o meso, mas conseguims atingi-lo de formas diferentes.\nTambém conhecemos uma linguagem diferente do que provavelmente estamos acostumados, com características peculiares. Acredito que vale a pena dar uma atenção para uma lingaguem da família Lisp.\nPor fim, implementamos o FizzBuzz usando uma lingaugem declarativa funcional.\nAté a próxima!\n","permalink":"https://fabianobizarro.dev/blog/posts/programacao-funcional/","summary":"Fala pessoal, beleza?\nHoje vamos ver sobre o paradigma de programação funcional, um pouco de sua história e vamos resolver o FizzBuzz usando a linguagem Clojure.\nO Paradigma O paradigma funcional tem como base o uso de funções para a realização das operações. Quando falamos em função, é literalmente uma função matemática (aquelas funções que você deve ter visto na escola)\nConsidere a função:\nf(x) = x * 2 avaliar este texto","title":"Programação Funcional"},{"content":"Fala pessoal, beleza?\nHoje vamos ver sobre o paradigma de programação estruturada, um pouco de sua história e vamos resolver o FizzBuzz de duas maneiras diferentes para comparação.\nO Paradigma Este paradigma tem como características o uso de estruturas de controles do fluxo de execução do código. São as estruturas if/else, while, do, for e qualquer outro tipo de estrutura que você conhecer.\nAs estruturas condicionais (if/else) nos permitem executar um bloco de código somente se uma condição lógica for satisfeita, ou caso o contrário também.\nif (\u0026lt;condição\u0026gt;) { //execução de um bloco de código } else { //execução de um bloco de código } A sintaxe pode variar de acordo com a linguagem que você usar, mas a ideia é a mesma.\nAs estruturas de repetição (for, while, do, etc.) nos permitem executar um bloco de código repetidas vezes, até que uma condição seja alcançada para que aquele fluxo seja finalizado.\nwhile (\u0026lt;condição\u0026gt;) { //execução de um bloco de código } Enquanto essa condição for verdadeira, este bloco de código será repetido; uma vez que a condição for falsa, o fluxo de execução dessa estrutura é interrompido.\nEm seu livro Arquitetura Limpa, Robert Martin fala o seguinte:\n“A programação estruturada impõe disciplina sobre a transferência direta do controle”\nMas o que isso quer dizer?\nQuer dizer que você não pode (ou pelo menos não deve) seguir o fluxo de um código de forma aleatória ou desordenada; isso deve ser feito através dessas estruturas de controle que as linguagens possuem, para evitar que você tenha problemas na execução do seu código.\nJá ouviu falar no GOTO? Sim, é isso que queremos evitar.\nUm pouco de história A programação estruturada foi descoberta por Edsger Dijkstra em 1968. Ele conseguiu demonstrar que o uso de saltos (goto) é prejudicial para a estrutura de um programa.\nImagine um programa e uma ordem de execução do código, onde cada linha é executada, seguida pela próxima, iniciando da primeira linha do seu código. Com esse comando GOTO, você consegue fazer com que a execução “salte” para um determinado local do seu código e continue de lá.\nEm 1968, Dijkstra publicou um artigo intitulado “Go To Statement Considered Harmful” onde ele falava dos problemas do uso da instrução GOTO, e sobre as estruturas de controle.\nAparentemente a comunidade não ficou feliz na época, o bicho pegou (imagine se existissem as redes sociais como hoje), mas no fim Dijkstra venceu e isso virou um padrão. Todas as linguagens hoje possuem essas estruturas de controle, e o uso de GoTo é desencorajado por todos.\nGolang A linguagem que vou utilizar para resolver o FizzBuzz é a Go (ou golang, como também é conhecida).\nGo foi criada em 2007 por Robert Griesemer, Rob Pike e Ken Thompson (sim, o mesmo cara da linguagem C e do Unix) dentro do Google; seu objetivo é ser expressiva, eficiente e eficaz para escrever programas confiáveis e robustos.\nUma de suas inspirações é a linguagem C, onde herdou a sintaxe das expressões, passagem de parâmetro por valor, ponteiros, entre outras coisas.\nÉ uma linguagem poderosa, simples e fácil de aprender.\nFizzBuzz Vamos ao que interessa, resolver o FizzBuzz usando o paradigma Imperativo Estrutural.\nPrimeiro, começamos declarando o nome do pacote e importando a biblioteca fmt que usaremos para escrever as informações no console.\npackage main import \u0026#34;fmt\u0026#34; func main() { } Depois declaramos uma variável count que usaremos para facilitar o controle da execução. Vou deixar com o valor de 15, mas caso você queira rodar o fizzbuzz com um valor diferente, basta alterar esta variável.\nEm seguida, nós inserimos uma estrutura de repetição para executar um bloco de código repetidas vezes.\nfor i := 1; i \u0026lt;= count; i++ { } Todo o código dentro desse par de chaves será executado 15 vezes, ao final de cada iteração, essa variável i é incrementada em 1 (por isto essa sintaxe i++).\nAgora que temos nossa iteração configurada, vamos começar a validar os números.\nSe o número for divisível por 3 e 5 então temos que escrever \u0026ldquo;FizzBuzz\u0026rdquo;, isso traduzido em código fica assim:\nif i % 3 == 0 \u0026amp;\u0026amp; i % 5 == 0 { } Se você não entendeu nada do que está escrito ali:\nO operador % é responsável por retornar o resto da divisão entre dois números. Ex.: 10 % 2 representa o resto da divisão de 10 por 2; \u0026amp;\u0026amp; é o operador lógico AND, ele retorna verdadeiro se os dois operadores forem verdadeiro também.; Uma tradução para o português seria: Se o resto da divisão entre i e 3 é zero e entre i e 5 também é zero, então execute o bloco de código. Se a condição for verdadeira, então devemos escrever o FizzBuzz na tela:\nif i % 3 == 0 \u0026amp;\u0026amp; i % 5 == 0 { fmt.Print(\u0026#34;FizzBuzz \u0026#34;) } Para simplificar um pouco, ao invés de verificar se o número é múltiplo de 3 e de 5, podemos verificar se ele é múltiplo de 15, deixando o código um pouco mais limpo, mas com o mesmo resultado.\nif i % 15 == 0 { fmt.Print(\u0026#34;FizzBuzz \u0026#34;) } A ideia segue a mesma, agora com as outras validações, se o número for múltiplo de 5, devemos escrever Buzz:\nif i % 5 == 0 { fmt.Print(\u0026#34;Buzz \u0026#34;) } Se o número for múltiplo de 3, então escrevemos Fizz:\nif i % 3 == 0 { fmt.Print(\u0026#34;Fizz \u0026#34;) } Caso o contrário, nós escrevemos o número na tela. Juntando tudo, nós temos o seguinte código:\npackage main import \u0026#34;fmt\u0026#34; func main() { count := 15 for i := 1; i \u0026lt;= count; i++ { if i % 15 == 0 { fmt.Print(\u0026#34;FizzBuzz \u0026#34;) } else if i % 5 == 0 { fmt.Print(\u0026#34;Buzz \u0026#34;) } else if i % 3 == 0 { fmt.Print(\u0026#34;Fizz \u0026#34;) } else { fmt.Printf(\u0026#34;%d \u0026#34;, i) } } } O resultado:\n1 2 Fizz 4 Buzz Fizz 7 8 Fizz Buzz 11 Fizz 13 14 FizzBuzz Simples, correto?\nPara mim é algo trivial, já que comecei na programação com linguagens imperativas estruturadas, então isso parece muito natural, como poderia existir algo sem uma estrutura de repetição?\nUma resolução não estruturada Bem, decidi então fazer a resolução do mesmo problema, porém sem usar estruturas de repetição, parar ter uma ideia de como seria programar sem esse tipo de restrição que o paradigma nos impõe.\nFiz o mesmo exemplo em Batch, porém usando “saltos” com as instruções GOTO, e ficou assim:\n@echo off SET /A max = 15 SET /A count = 1 GOTO :handling :increase_counter SET /A count = %count% + 1 if %count% GTR %max% GOTO :EOF :handling :handle_15 SET /a m = %count% %% 15 if %m% == 0 ( echo FizzBuzz GOTO :increase_counter ) :handle_3 SET /a m = %count% %% 3 if %m% == 0 ( echo Fizz GOTO :increase_counter ) :handle_5 SET /a m = %count% %% 5 if %m% == 0 ( echo Buzz GOTO :increase_counter ) :handle_number echo %count% GOTO :increase_counter Repare na diferença do código, como fica mais complexo usando os saltos, e muito mais suscetível ao erro. Nós conseguimos criar identificações de áreas no código, como o :increase_counter, conseguimos mover a execução para esta área a qualquer momento, usando o GOTO :increase_counter.\nA estrutura de repetição faz com que não seja preciso usar esses saltos, e nos dá uma abstração para realizar essa tarefa: muito mais prático usar um laço for do que goto para controlar o fluxo.\nConclusão Vimos como o paradigma estrutural nos restringe quanto aos saltos no código, e como isso é benéfico para o desenvolvimento de software.\nFoi possível ter uma noção da evolução das linguagens com o tempo, e como essa evolução afeta a experiência de programação.\nResolvemos o FizzBuzz usando a programação imperativa estruturada, agora temos uma base para comparar com os próximos paradigmas.\nAté a próxima!\nReferências Arquitetura Limpa - Robert C. Martin A Linguagem de Programação Go - Alan A. A. Donovan, Brian W. Kernighan ","permalink":"https://fabianobizarro.dev/blog/posts/programacao-estruturada/","summary":"Fala pessoal, beleza?\nHoje vamos ver sobre o paradigma de programação estruturada, um pouco de sua história e vamos resolver o FizzBuzz de duas maneiras diferentes para comparação.\nO Paradigma Este paradigma tem como características o uso de estruturas de controles do fluxo de execução do código. São as estruturas if/else, while, do, for e qualquer outro tipo de estrutura que você conhecer.\nAs estruturas condicionais (if/else) nos permitem executar um bloco de código somente se uma condição lógica for satisfeita, ou caso o contrário também.","title":"Programação Estruturada"},{"content":"Fala pessoal, beleza?\nNeste post (e nos próximos) vou comentar um pouco sobre os paradigmas de programação e suas implementações em algumas linguagens.\nMinha ideia é analisar como um determinado problema pode ser resolvido de diferentes formas por diferentes paradigmas e linguagens.\nCada paradigma e linguagem tem suas características e isso nos ajuda a pensar de forma diferente.\nO que é um paradigma de programação? Um paradigma é uma forma de se programar, onde temos um modelo a ser seguido. Cada paradigma tem seu conjunto de regras e estruturas usadas em sua implementação.\nUm paradigma pode ser melhor que outro para resolver um determinado problema.\nOs paradigmas Existe um certo agrupamento de paradigmas, são eles:\nImperativo Estruturado; Orientado a objetos; Declarativo Funcional; Lógico. Existem algumas outras classificações de paradigmas, mas vou me concentrar nessas.\nImperativo É o paradigma que descreve o processamento e a lógica em ações e comandos que podem ou não alterar o estado de um valor. Neste paradigma, nós falamos ao computador como fazer uma determinada tarefa. O nome do paradigma tem a ver com tempo verbal imperativo. São comandos com \u0026ldquo;faça\u0026rdquo;, \u0026ldquo;escreva\u0026rdquo;, “calcule”.\nExemplos de linguagens: FORTRAN, COBOL, C,\nEstrutural Podemos dizer que este paradigma está relacionado (ou é um subtipo) com o paradigma imperativo.\nUma característica aqui é que este paradigma impõe sobre a estrutura de controle de execução: temos estruturas que controlam o fluxo de execução do código (os famosos is/else, for, while e etc.).\nExemplos de linguagens: C, C++, Pascal, Java, PHP\nOrientado a Objetos Outro paradigma relacionado ao Imperativo, o paradigma Orientado a Objetos apresenta características que nos permitem agrupar e relacionar estado e comportamento: os objetos.\nUm objeto pode ter propriedades para descrever seu estado, e funções que têm o comportamento de alterá-lo.\nExistem 3 conceitos que são bastante utilizados neste paradigma: Encapsulamento, Herança e Polimorfismo.\nExemplos de linguagens: Smalltalk, C#, Java, C++, Python, Ruby\nDeclarativo É um paradigma onde temos declarações de dados e estruturas, mas não temos a declaração das instruções e comandos da máquina. É como se nós informássemos ao computador como querermos as coisas, e não como fazê-las, diferente da programação imperativa.\nExemplos de linguagens: Prolog, Haskell, SQL\nFuncional Baseado no conceito de funções matemáticas, este paradigma faz uso dessas funções e expressões para a transformação de um estado. Um conceito importante neste paradigma é o da imutabilidade.\nAo invés de ter um procedimento que altere o estado de um determinado dado, a ideia neste paradigma é que este procedimento gera um novo estado baseado no dado original, garantindo a imutabilidade deste.\nExemplos de linguagens: F#, Haskell, Clojure, ML\nLógico Consiste na ideia de se construir um conjunto de fatos e regras, e a partir destas o computador tenta encontrar uma solução.\nExemplos de linguagens: Prolog, Datalog\nLinguagens multiparadigma Uma linguagem de programação pode implementar diversos paradigmas, o que torna ela uma linguagem multiparadigma.\nAlguns exemplos: C#, Python, C++, Ruby, Swift, Kotlin\nO desafio O desafio que vou utilizar para comparar os paradigmas e as linguagens é o FizzBuzz.\nÉ um desafio de solução bem simples, mas que é o suficiente para podermos ver as implementações em diferentes formas.\nA tarefa é a seguinte: escrever um programa que imprima os números de 1 a N, sendo que se o número for múltiplo de 3, deve ser impresso “Fizz” no lugar do número, se for múltiplo de 5, deve ser impresso “Buzz”, se for múltiplo de 3 e 5, deve ser impresso “FizzBuzz”. Se não entrar nessas condições, então deve ser impresso o número normalmente.\nO resultado esperado é algo assim:\n1, 2, Fizz, 4, Buzz, Fizz, 7, 8, Fizz, Buzz, 11, Fizz, 13, 14, Fizzbuzz, 16, 17, Fizz, 19, Buzz, Fizz, 22, 23, Fizz, Buzz, 26, Fizz, 28, 29, Fizzbuzz, 31, 32, Fizz, 34, Buzz, Fizz, ... Nas próximas postagens, vamos ver sobre a resolução do Fizzbuzz em diferentes formas, e analisar um poucos os paradigmas e linguagens de programação.\nAté a próxima!\n","permalink":"https://fabianobizarro.dev/blog/posts/paradigmas-programacao/","summary":"Fala pessoal, beleza?\nNeste post (e nos próximos) vou comentar um pouco sobre os paradigmas de programação e suas implementações em algumas linguagens.\nMinha ideia é analisar como um determinado problema pode ser resolvido de diferentes formas por diferentes paradigmas e linguagens.\nCada paradigma e linguagem tem suas características e isso nos ajuda a pensar de forma diferente.\nO que é um paradigma de programação? Um paradigma é uma forma de se programar, onde temos um modelo a ser seguido.","title":"Paradigmas de Programação"}]